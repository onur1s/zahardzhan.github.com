---
layout: post
title: Интегрированные среды и линукс на десктопе
---

<p>
Последний срач в Google Buzz заставил меня задуматься и поразмыслить
насчёт консоли в современных никсах и о больших системах.
</p>
<p>
Противопоставление разных подходов к интерфейсам и специализация
интерфейсов на определенных подходах не дает ничего хорошего. В UNIX
эта беда заметнее чем во многих других системах.
</p>
<p>
Я перепробовал множество минималистичных <i>плиточных</i> оконных
менеджеров. Среди них были очень толковые, но ни один из них меня не
устроил: все они были слишком зациклены на клавиатуре — большинство из
них просто игнорировало мышь как таковую. Это глупость со стороны
авторов этих программ — от плиточных оконных менеджеров толку больше
всего в связке с мышью, что продемонстрировал <a href="http://www.apple.com/ipad">iPad</a>, тем более, что
основная программа на десктопе современного пользователя — браузер,
целиком и полностью ориентирована на мышь.
</p>
<p>
В результате я использую гном. Он достаточно хорош для всего — он просто
работает достаточно хорошо.
</p>
<p>
С консолью та же беда. Это может прозвучать глупо, вроде как консоль —
она на то и консоль, чтобы быть текстовой, и мышь тут не при делах. Но
нет — даже в консоли поддержка мыши очень важна. Трудно отказаться от
убойной фичи копирования выделением мыши и вставки по щелчку двумя
кнопками. В древней операционке Open Genera для лисп машин в консоли
была полная поддержка мыши, графики и гипертекста. Но это было больше
20-ти лет назад.
</p>
<p>
Консоль в UNIX, в том виде в котором она есть сейчас мало того что
практически бесполезна для пользователя (простого пользователя), в
большинстве случаев она просто вредна.
</p>
<p>
Я пользуюсь консолью в Ubuntu 10.04 в пяти случаях:
</p>
<ol>
<li>
Запуск <i>mplayer</i> с субтитрами. Это долго и нудно, но smplayer
тормозной, а стандартный проигрыватель не поддерживает FullHD.

</li>
<li>
Перезапуск сбойного pulseaudio. Здесь даже и говорить нечего.

</li>
<li>
Установка софта через <i>apt</i>. Установка софта через консоль — это
очень удобно, тут уж ничего не скажешь.

</li>
<li>
Работа с <i>git</i> (в большинстве случаев консоли я предпочитаю Emacs,
но порой проще через консоль), пакетными менеджерами, системами
сборки, etc. Профессиональный софт удобно использовать в консоли,
на то он и профессиональный.

</li>
<li>
Правки из-под <i>sudo</i> в труднодоступных местах. Это уже из области
техобслуживания, простой пользователь во внутренности системы не
полезет, а игры с sudo опасны. Неосторожный <code>rm -Rf /</code> или даный
добрым другом «скрипт для оптимизации системы» может иметь очень
нехорошие последствия.

</li>
</ol>

<p>В остальном — от консоли толку нет.
</p>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">Путь UNIX </h3>
<div class="outline-text-3" id="text-1">


<p>
А как же классический UNIX-way: скрипты, pipe'ы, и т.п? Только если вы
сисадмин или упоротый сисадминистый пользователь, которому настолько
нечего делать, что он использует все эти навороченые классические
консольные инструменты (за пределами элементарных rm, mkdir, cp,
chmod, конечно — эти достаточно просты, чтобы быть полезными).
</p>
<p>
У меня есть книжка в формате PDF. Я хочу её почитать. Как я сделаю это
через интерфейс консоли и через интерфейс командной строки поиска
Google в Chrome?
</p>

</div>

<div id="outline-container-1_1" class="outline-4">
<h4 id="sec-1_1">Zsh </h4>
<div class="outline-text-4" id="text-1_1">


<ul>
<li>
Надо почитать книжку, для этого надо открыть её.

</li>
<li>
Вот только я не помню где она лежит — надо найти её.

</li>
<li>
Я читал в учебнике для <i>системных администраторов</i> что для этого
используется команда <code>find</code>.

</li>
<li>
Чтобы узнать (или вспомнить, потому что правила использования такого навороченого
механизма полностью стираются из памяти после использования) надо
прочесть мануал.

</li>
<li>
Открываю терминал, набираю:

<pre class="example">
man find
</pre>


</li>
<li>
Проходит 5 минут. Как все сложно! Открываем вторую
консоль и уже в ней продолжаем:

<pre class="example">
find -name "SICP*" -type f -exec evince
find: отсутствует аргумент у `-exec' 
</pre>


<p>
Результат нулевой — команда набрана неправильно. (Ах, да,
пользователю нужно еще знать регулярные выражения).
</p>
</li>
<li>
Еще разок:

<pre class="example">
find -name "SICP*" -type f -exec evince '{}' \;
</pre>


<p>
Заработало, только вот команду надо запускать <i>всегда</i> 2 раза: если
в первый раз найдется 2000 файлов, то это будет кромешный
ужас. Опечатки в команде приведут к еще более кромешному — можно
тупо просрать все свои файлы. Откатить будет невозможно — в UNIX нет
корзины. <code>Find</code> ищет по всей домашней директории, и если у меня 2 Тб
всякого говна на винте я представляю, сколько времени она будет
искать.
</p>
</li>
</ul>

<p>Итого, прошло около 12 минут. 12 минут чтобы почитать книжку — это
нечто запредельное (боюсь, не освоившийся в консоли пользователь
потратит на это куда больше времени). И это с учетом того, что нужно
знать иностранный язык, чтобы прочесть мануал. И разбираться в
тонкостях запуска команд в консоли.
</p>
</div>

</div>

<div id="outline-container-1_2" class="outline-4">
<h4 id="sec-1_2">Google Chrome </h4>
<div class="outline-text-4" id="text-1_2">


<p>
Как эта задача решается в хроме.
</p>
<ol>
<li>
Открываем хром.
</li>
<li>
Открываем новую вкладку.
</li>
<li>
Печатаем «SICP». Хром выдает список с вариантом «SICP PDF». Дважды вниз, один Enter. 
</li>
<li>
Похоже, 4-ый результат — это то, что надо. 
</li>
<li>
Тык.

</li>
</ol>

<p>Наслаждаемся. 
</p>
<p>
Окей, это заняло около 20 секунд. Никаких чтений мануалов. Пишешь что
хочешь — получаешь что хочешь. Это — командный интерфейс для людей.
</p>
<p>
А теперь у меня возникает вопрос. Если и адресная строка хрома и
юниксовая консоль — командные интерфейсы, то почему я должен тратить
столько времени, пользуясь юниксовой консолью, чтобы почитать книжку?
Если я в десятки раз быстрее сделаю то же самое в хроме.
</p>
<p>
Консоль, в том виде в котором она есть в Linux не так хороша как могла
бы быть. Более чем реально сделать её в разы более удобной, полезной,
простой, понятной и безопасной. Не стоит зацикливаться на древних, как
говно мамонта, методах (классический UNIX-вэй) — будущее за
интегрированными системами, совмещающими в себе плюсы всех подходов.
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">Интегрированные системы </h3>
<div class="outline-text-3" id="text-2">


<p>
Людям, сведущим в технике, нравятся интегрированные системы (оставим в
стороне тех, кому нравится <i>интегрировать</i> системы — привет,
пользователи Gentoo (или, прости хосподи, LFS)). Им нравятся
минималистичные системы (оставим в стороне программистов на C++ под
Windows).
</p>
<p>
Я могу назвать несколько таких систем.
</p>
<dl>
<dt>Chrome</dt><dd>
Образцово-показательная минималистичная интегрированная
система. Будущая Chrome OS тому подтверждение.

</dd>
<dt>Лисп</dt><dd>
Простой, минималистичный язык программирования, в который с
завидной легкостью интегрируются любой другой язык
программирования. Его любят за это. И ненавидят за скобочки.

</dd>
<dt>Emacs</dt><dd>
Emacs — минималистичный? Не смеши меня! — Скажут мне
некоторые. Ну или почти все.

<p>
Нет, на самом деле Emacs — минималистичный. У него
(относительно) небольшое ядро, а все его модули расширения
(тысячи их) написаны на лиспе. Другое дело, что Эмакс
используется уже несколько десятилетий, и область его
применения столь широка, что сравнить её можно, разве что с
Chrome OS — потому он довольно большой. Интегрированности
эмакса может позавидовать любая другая система, кроме,
разве что
</p>
</dd>
<dt>Лисп Машина</dt><dd>
Emacs некогда был лишь частью лисп-машины, наверное,
самой интегрированной системы за всю компьютерную
историю. Что и говорить, лисп-машины нравились
программистам. И определенно больше, чем им нравится
сейчас UNIX.
</dd>
</dl>

</div>
</div>
