---
layout: post
title: Hello, Deadlock!
---

Программная транзакционная память в Clojure предоставляет программисту
простые, мощные и безопасные инструменты для многопоточного
программирования. Эти инструменты сконструированы с учетом типичных
ошибок и проблем в многопоточных программах. Например, Clojure STM
гарантирует что взаимные блокировки никогда не возникнут в процессе её
работы.

## Взаимная блокировка

*Взаимная блокировка* (deadlock) возникает в многопоточной среде когда
 несколько потоков находятся в состоянии бесконечного ожидания
 ресурсов, захваченных самими этими потоками.

## Раздолье для граблей

Даже не смотря на то, что кто-то там что-то гарантирует, при должном
навыке можно умудриться нарваться на добрую парочку старых добрых
граблей многопоточного программирования.

Возьмем агента **a**. 

    #!clojure
    (def a (agent 1))           ;; a = 1

Агент выполняет действие в отдельном потоке:

    #!clojure
    (send-off a (constantly 2)) ;; a = 2

Попытка организовать взаимную блокировку в лоб обречена — агент не
может ожидать окончания выполнения действия в самом действии:

    #!clojure
    (send-off a #(do (await a) %))

    (agent-errors a)
    > (#<Exception java.lang.Exception: Can't await in agent action>)
    (clear-agent-errors a)      ;; a = 2

Future выносит ожидание окончания выполнения дейтсвия агента в
отдельный поток, который блокируется в потоке действия — происходит
взаимоблокировка потоков.

    #!clojure
    (send-off a #(do (deref (future (await a))) %))

Вуаля — наш агент впал в кому, и больше на сообщения не реагирует.

    #!clojure
    (send-off a (constantly 3))
    (send-off a (constantly 4))
    
    > a
    #<Agent@asdf: 2>
