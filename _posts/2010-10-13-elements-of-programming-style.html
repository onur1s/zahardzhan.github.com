---
layout: post
title: Элементы стиля программирования
---

<p>
Многие технические книги начинаются с ужасно скучного и муторного
введения. Исключений немного, и книга «Идеальный код», о которой я
рассказал в прошлом посте — одна из тех, введение которой стоит
прочесть.
</p>
<p>
Математические книги нужно читать имея под рукой ручку и бумагу, все
остальные — имея под рукой гугл. Последний раз когда я читал введение
в «Идеальный код», у меня не было под рукой гугла. Думаю, тогда я
упустил из виду нечто важное.
</p>
<p>
Вот первые два абзаца:
</p>
<blockquote>

<p>Я начал работать программистом летом 1982 года. Через пару недель
после этого один из системных администраторов дал мне почитать книги
«The Elements of Programming Style», Brian W. Kernighan,
P. J. Plauger, и «Algorithms + Data Structures = Programs», Niklaus
Wirth.
</p>
<p>
Это стало для меня открытием. Я впервые узнал, что программы — это
нечто большее, чем простые инструкции для компьютера. Они могут быть
элегантными, как ближайшее окружение президента, изящными, как
подвесной мост, и красноречивыми, как эссе Джорджа Оруэлла.
</p>
</blockquote>


<p>
Наверняка про книгу Вирта слышали многие. А вот про старую книгу
Кернигана — наврядли. В сети на этот счет глухо — есть электронная
версия перевода времен СССР, но она лежит на буржуйском ресурсе с
повременным доступом, поэтому скопировать её за вменяемое время не
представляется возможным.
</p>


<div class="figure">
  <a href="/images/elements-of-programming-style.jpg">
    <img src="/images/elements-of-programming-style.jpg"
         alt="Обложка «The Elements of Programming Style»">
  </a>
</div>

<p>
«Элементы стиля программирования» это небольшой ~150-страничный
сборник примеров кода с пояснениями, почему приведенный код —
говно. Книга действительно древняя, все примеры написаны на Фортране и
PL/1 с обилием прелестей а'ля <code>20 goto 10</code>, но внимания заслуживают
несколько десятков «правил», разбросанных по всей книге. Определенно,
эти правила важны как история становления философии UNIX. Очень
<a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F_UNIX">похожие правила</a> можно найти в книге Рэймонда «Искусство
программирования для UNIX».
</p>
<p>
Ниже вы увидите большую часть этих правил и немного моих комментариев.
</p>
<blockquote>

<p>Перефразируя высказывание из «Элементов стиля» («Elements of Style» by
Strunk &amp; White), правила стиля программирования, как и стиля
английского языка, иногда нарушают даже лучшие писатели. Впрочем,
когда правило нарушается, обычно в программе находится некое
компенсирующее качество, которое достигается за счет нарушения. Если
вы не уверены в улучшении, вероятно, лучше всего будет следовать
правилам.
</p>
</blockquote>


<ol>
<li>
Говорите то, что вы имеете в виду, просто и прямо.

<p>
Сама суть философии UNIX: «Будь проще, тупица».
</p>
</li>
<li>
Пишите программы просто — не делайте их слишком
хитроумными. 

<p>
Аналогично <i>Правилу ясности</i>: Ясность лучше заумности.
</p>
<p>
Чаще всего этим грешат хаскеллисты и большие любители
паттернов проектирования.
</p>
</li>
<li>
Пользуйтесь библиотечными функциями.

</li>
<li>
Избегайте промежуточных переменных.

</li>
<li>
Пишите понятно — не жертвуйте ясностью ради «эффективности».

</li>
<li>
Пусть машина делает грязную работу.

<p>
Аналогично <i>Правилу экономии</i>: Время программиста дорого; сократите
его, используя машинное время.
</p>
</li>
<li>
Заменяйте повторяющиеся выражения вызовами функций.

<p>
Лисперы добавят: заменяйте повторяющиеся управляющие конструкции
макросами.
</p>
</li>
<li>
Скобки исключают двусмысленность.

<p>
Обилие скобочек в правильных местах избавит от двусмысленности,
повысит читаемость и увеличит расширяемость — лисперы знают о чем я
(loop &amp; iterate).
</p>
</li>
<li>
Выбирайте имена переменных так, чтобы они не приводили к путанице.

</li>
<li>
Не используйте goto, если хотите сохранить программу читаемой.

<p>
Мантра «структурного программирования».
</p>
</li>
<li>
Избегайте ненужных ветвлений.

</li>
<li>
Используйте хорошие средства языка и не используйте плохие.

<p>
Над этим правилом уже 20 лет ломают голову программисты на С++.
</p>
</li>
<li>
Используйте «телефонный тест» для проверки читабельной программы.

<p>
Как в анекдоте: если Рабинович сможет правильно «напеть» вашу
программу — она прошла тест.
</p>
</li>
<li>
Используйте сдвиг строк (<i>идентацию</i>) для разделения блоков кода.

<p>
Если пишите на питоне — можете проигнорировать это правило.
</p>
</li>
<li>
Делайте программы читаемыми сверху вниз.

</li>
<li>
Используйте if и else чтобы подчеркнуть необходимость выполнения
только одного из двух действий.

</li>
<li>
Используйте if &hellip; else if &hellip; else для ветвлений по нескольким
направлениям.

</li>
<li>
Пользуйтесь основными конструкциями потока управления.

</li>
<li>
Если логическое выражение трудно понять — попробуйте его
преобразовать.

</li>
<li>
Пусть данные определяют структуру программы.

<p>
Аналогично <i>Правилу представления</i> Реймонда: Храните знания в
данных так, чтобы логика программы была тупой и надёжной.
</p>
</li>
<li>
Сперва напишите на псевдокоде, потом переведите на машинный язык.

<p>
Литературное программирование пошло дальше в этом подходе — сперва
напишите на псевдокоде, а потом <i>допишите</i> машинным языком.
</p>
</li>
<li>
Каждый модуль должен выполнять одну функцию, но хорошо.

</li>
<li>
Не исправляйте плохую программу — перепишите её.

</li>
<li>
Пишите и тестируйте программу небольшими частями.

</li>
<li>
Используйте рекурсивные процедуры для рекурсивных структур данных.

<p>
Рекурсия не должна быть затычкой в каждой бочке (как в языке
Scheme), с ней нужно быть очень осторожным — по убийственной силе
она близка старому доброму goto (если считаете иначе — попробуйте
разобраться в системе из хотя бы трех взаиморекурсивных
функций). В большинстве случаев лучше предпочесть итеративные
конструкции рекурсивным.
</p>
</li>
<li>
Проверяйте вводимые данные на обоснованность и правдоподобие.

</li>
<li>
Убедитесь, что входные данные не приведут к вылету программы.

</li>
<li>
Определяйте плохие входные данные; восстанавливайтесь, если это
возможно.

</li>
<li>
Делайте входные данные легкими для подготовки, а выходные —
понятным.

</li>
<li>
Используйте единый формат ввода.

</li>
<li>
Делайте входные данные легко корректируемыми.

</li>
<li>
Делайте входные данные понятными и используйте значения
по-умолчанию.

</li>
<li>
Инициализируйте переменные перед использованием.

</li>
<li>
Тестируйте программы на граничных условиях.

</li>
<li>
Убедитесь, что особые случаи действительно особые.

</li>
<li>
Проверте некоторые результаты вручную.

</li>
<li>
Будте осторожными в вычислениях с плавающими точками и дробями.

</li>
<li>
Сделайте программу правильной перед тем как сделать её быстрой.

</li>
<li>
Сделайте программу отказоустойчивой перед тем как сделать её
быстрой.

</li>
<li>
Сделайте программу ясной перед тем как сделать её быстрой.

</li>
<li>
Оставте простые оптимизации компилятору.

</li>
<li>
Не напрягайтесь с повторным использованием кода; вместо этого —
реорганизуйте его.

</li>
<li>
Держите программу простой чтобы сделать её быстрой.

</li>
<li>
Не раздувайте код чтобы сделать его быстрым — найдите лучший
алгоритм.

</li>
<li>
Используйте профайлер. Измеряйте скорость перед тем как делать
программу «эффективнее».

</li>
<li>
Убедитесь, что комментарии и код совпадают.

</li>
<li>
Не повторяйте код в комментариях — сделайте каждый комментарий
значимым.

</li>
<li>
Не комментируйте плохой код — перепишите его.

</li>
<li>
Используйте значащие имена переменных и имена меток goto.

</li>
<li>
Форматируйте программу так, чтобы помочь читателю понять её.

</li>
<li>
Документируйте структуры данных.

</li>
<li>
Не комментируйте сверх меры.
</li>
</ol>

