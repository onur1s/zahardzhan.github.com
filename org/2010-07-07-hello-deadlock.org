#+OPTIONS: H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t TeX:t LaTeX:nil skip:nil d:t tags:not-in-toc
#+STARTUP: SHOWALL INDENT
#+STARTUP: HIDESTARS
#+BEGIN_HTML
---
layout: post
title: Hello, Deadlock!
---
#+END_HTML

Программная транзакционная память в Clojure предоставляет программисту
простые, мощные и безопасные инструменты для многопоточного
программирования. Эти инструменты сконструированы с учетом типичных
ошибок и проблем в многопоточных программах. Например, Clojure STM
гарантирует что взаимные блокировки никогда не возникнут в процессе её
работы.

Но даже не смотря на то, что STM что-то гарантирует, при должном
навыке можно умудриться нарваться на добрую парочку старых добрых
граблей многопоточного программирования.

/Взаимная блокировка/, /deadlock/, возникает в многопоточной среде
когда несколько потоков находятся в состоянии бесконечного ожидания
ресурсов, захваченных самими этими потоками.

Например, для агента

#+BEGIN_SRC clojure
(def a (agent nil))
#+END_SRC

попытка организовать взаимную блокировку в лоб обречена на провал —
STM нам этого не позволит — агент не может ожидать окончания
выполнения действия в самом действии:

#+BEGIN_SRC clojure
(send-off a #(do (await a) %))

> (agent-error a)
#<Exception java.lang.Exception: Can't await in agent action>
#+END_SRC

=future= выносит ожидание окончания выполнения дейтсвия агента в
отдельный поток, который затем блокируется в потоке действия — происходит
взаимоблокировка потоков.

#+BEGIN_SRC clojure
(send-off a #(do (deref (future (await a))) %))
#+END_SRC

Вуаля — наш агент впал в кому, и больше на сообщения не реагирует:

#+BEGIN_SRC clojure
(send-off a (constantly true))

> a
#<Agent@asdf: nil>
#+END_SRC
